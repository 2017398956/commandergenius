--- findversion.sh	2014-02-25 11:17:27.000000000 +0200
+++ findversion.sh	2014-03-13 22:51:42.431059430 +0200
@@ -134,6 +134,7 @@
 	REV_NR=""
 fi
 
+MODIFIED="0" # This prevents Andorid build from connecting to a public servers
 if [ "$MODIFIED" -eq "2" ]; then
 	REV="${REV}M"
 fi
--- src/debug.cpp	2014-02-25 11:17:24.000000000 +0200
+++ src/debug.cpp	2014-03-13 22:51:41.679014683 +0200
@@ -16,6 +16,9 @@
 #include "string_func.h"
 #include "fileio_func.h"
 #include "settings_type.h"
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
 
 #include <time.h>
 
@@ -107,6 +110,9 @@
  */
 static void debug_print(const char *dbg, const char *buf)
 {
+#ifdef __ANDROID__
+	__android_log_print(ANDROID_LOG_INFO, "OpenTTD", "[%s] %s", dbg, buf);
+#endif
 #if defined(ENABLE_NETWORK)
 	if (_debug_socket != INVALID_SOCKET) {
 		char buf2[1024 + 32];
--- src/fontdetection.cpp	2014-02-25 11:17:24.000000000 +0200
+++ src/fontdetection.cpp	2014-03-13 23:49:24.456780663 +0200
@@ -626,7 +626,7 @@
 	if (split != NULL) *split = '\0';
 
 	/* First create a pattern to match the wanted language. */
-	FcPattern *pat = FcNameParse((FcChar8*)lang);
+	FcPattern *pat = FcNameParse((FcChar8*)"" /*lang*/);
 	/* We only want to know the filename. */
 	FcObjectSet *os = FcObjectSetBuild(FC_FILE, FC_SPACING, FC_SLANT, FC_WEIGHT, NULL);
 	/* Get the list of filenames matching the wanted language. */
@@ -639,6 +639,7 @@
 	if (fs != NULL) {
 		int best_weight = -1;
 		const char *best_font = NULL;
+		int best_missing_glypths = 65536;
 
 		for (int i = 0; i < fs->nfont; i++) {
 			FcPattern *font = fs->fonts[i];
@@ -664,12 +665,13 @@
 
 			callback->SetFontNames(settings, (const char*)file);
 
-			bool missing = callback->FindMissingGlyphs(NULL);
-			DEBUG(freetype, 1, "Font \"%s\" misses%s glyphs", file, missing ? "" : " no");
+			int missing = callback->FindMissingGlyphs(NULL);
+			DEBUG(freetype, 1, "Font \"%s\" misses %d glyphs for lang %s", file, missing, lang);
 
-			if (!missing) {
+			if (missing < best_missing_glypths) {
 				best_weight = value;
 				best_font   = (const char *)file;
+				best_missing_glypths = missing;
 			}
 		}
 
@@ -677,6 +679,7 @@
 			ret = true;
 			callback->SetFontNames(settings, best_font);
 			InitFreeType(callback->Monospace());
+			DEBUG(freetype, 1, "Selected font %s for lang %s", best_font, lang);
 		}
 
 		/* Clean up the list of filenames. */
--- src/music/libtimidity.cpp	2014-02-25 11:17:00.000000000 +0200
+++ src/music/libtimidity.cpp	2014-03-13 22:51:41.711016587 +0200
@@ -13,6 +13,7 @@
 #include "../openttd.h"
 #include "../sound_type.h"
 #include "../debug.h"
+#include "../core/math_func.hpp"
 #include "libtimidity.h"
 #include <fcntl.h>
 #include <sys/types.h>
@@ -22,6 +23,7 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <timidity.h>
+#include <SDL.h>
 #if defined(PSP)
 #include <pspaudiolib.h>
 #endif /* PSP */
@@ -51,6 +53,24 @@
 	}
 }
 #endif /* PSP */
+#ifdef __ANDROID__
+/* Android does not have Midi chip, we have to route the libtimidity output through SDL audio output */
+void Android_MidiMixMusic(Sint16 *stream, int len)
+{
+	if (_midi.status == MIDI_PLAYING) {
+		Sint16 buf[16384];
+		while( len > 0 )
+		{
+			int minlen = min(sizeof(buf), len);
+			mid_song_read_wave(_midi.song, stream, min(sizeof(buf), len*2));
+			for( Uint16 i = 0; i < minlen; i++ )
+				stream[i] += buf[i];
+			stream += minlen;
+			len -= minlen;
+		}
+	}
+}
+#endif /* __ANDROID__ */
 
 /** Factory for the libtimidity driver. */
 static FMusicDriver_LibTimidity iFMusicDriver_LibTimidity;
--- src/network/core/os_abstraction.h	2014-02-25 11:17:18.000000000 +0200
+++ src/network/core/os_abstraction.h	2014-03-13 22:51:42.427059192 +0200
@@ -161,7 +161,7 @@
 #		include <net/if.h>
 /* According to glibc/NEWS, <ifaddrs.h> appeared in glibc-2.3. */
 #		if !defined(__sgi__) && !defined(SUNOS) && !defined(__MORPHOS__) && !defined(__BEOS__) && !defined(__HAIKU__) && !defined(__INNOTEK_LIBC__) \
-		   && !(defined(__GLIBC__) && (__GLIBC__ <= 2) && (__GLIBC_MINOR__ <= 2)) && !defined(__dietlibc__) && !defined(HPUX)
+		   && !(defined(__GLIBC__) && (__GLIBC__ <= 2) && (__GLIBC_MINOR__ <= 2)) && !defined(__dietlibc__) && !defined(HPUX) && !defined(__ANDROID__)
 /* If for any reason ifaddrs.h does not exist on your system, comment out
  *   the following two lines and an alternative way will be used to fetch
  *   the list of IPs from the system. */
--- src/os/unix/crashlog_unix.cpp	2014-02-25 11:17:03.000000000 +0200
+++ src/os/unix/crashlog_unix.cpp	2014-03-13 22:51:42.427059192 +0200
@@ -141,7 +141,11 @@
 };
 
 /** The signals we want our crash handler to handle. */
+#ifdef __ANDROID__
+static const int _signals_to_handle[] = { }; // Default Android signal handler will give us stack trace
+#else
 static const int _signals_to_handle[] = { SIGSEGV, SIGABRT, SIGFPE, SIGBUS, SIGILL };
+#endif
 
 /**
  * Entry point for the crash handler.
--- src/os/unix/unix.cpp	2014-02-25 11:17:03.000000000 +0200
+++ src/os/unix/unix.cpp	2014-03-13 22:51:42.427059192 +0200
@@ -25,7 +25,7 @@
 
 #ifdef __APPLE__
 	#include <sys/mount.h>
-#elif (defined(_POSIX_VERSION) && _POSIX_VERSION >= 200112L) || defined(__GLIBC__)
+#elif ((defined(_POSIX_VERSION) && _POSIX_VERSION >= 200112L) || defined(__GLIBC__)) && !defined(__ANDROID__)
 	#define HAS_STATVFS
 #endif
 
@@ -254,6 +254,11 @@
 void cocoaReleaseAutoreleasePool();
 #endif
 
+#ifdef __ANDROID__
+#define main SDL_main
+extern "C" int CDECL main(int, char *[]);
+#endif
+
 int CDECL main(int argc, char *argv[])
 {
 	int ret;
--- src/osk_gui.cpp	2014-02-25 11:17:24.000000000 +0200
+++ src/osk_gui.cpp	2014-03-13 22:51:42.431059430 +0200
@@ -22,6 +22,9 @@
 
 #include "table/sprites.h"
 #include "table/strings.h"
+#ifdef __ANDROID__
+#include <SDL_screenkeyboard.h>
+#endif
 
 char _keyboard_opt[2][OSK_KEYBOARD_ENTRIES * 4 + 1];
 static WChar _keyboard[2][OSK_KEYBOARD_ENTRIES];
@@ -413,6 +416,16 @@
 
 	GetKeyboardLayout();
 	new OskWindow(&_osk_desc, parent, button);
+#ifdef __ANDROID__
+	char text[256];
+	SDL_ANDROID_GetScreenKeyboardTextInput(text, sizeof(text) - 1); /* Invoke Android built-in screen keyboard */
+	OskWindow *osk = dynamic_cast<OskWindow *>(FindWindowById(WC_OSK, 0));
+	osk->qs->text.Assign(text);
+	free(osk->orig_str_buf);
+	osk->orig_str_buf = strdup(osk->qs->text.buf);
+
+	osk->SetDirty();
+#endif
 }
 
 /**
--- src/script/api/script_date.cpp	2014-02-25 11:17:12.000000000 +0200
+++ src/script/api/script_date.cpp	2014-03-13 22:51:42.431059430 +0200
@@ -9,8 +9,8 @@
 
 /** @file script_date.cpp Implementation of ScriptDate. */
 
+#include "../../stdafx.h" /* Have to be included before time.h, if we want UINT32_MAX macro defined on Android */
 #include <time.h>
-#include "../../stdafx.h"
 #include "script_date.hpp"
 #include "../../date_func.h"
 
--- src/settings_gui.cpp	2014-02-25 11:17:23.000000000 +0200
+++ src/settings_gui.cpp	2014-03-13 23:01:22.521550369 +0200
@@ -323,17 +323,17 @@
 		switch (widget) {
 			case WID_GO_BASE_GRF_DESCRIPTION:
 				SetDParamStr(0, BaseGraphics::GetUsedSet()->GetDescription(GetCurrentLanguageIsoCode()));
-				DrawStringMultiLine(r.left, r.right, r.top, UINT16_MAX, STR_BLACK_RAW_STRING);
+				DrawString(r.left, r.right, r.top, STR_BLACK_RAW_STRING);
 				break;
 
 			case WID_GO_BASE_SFX_DESCRIPTION:
 				SetDParamStr(0, BaseSounds::GetUsedSet()->GetDescription(GetCurrentLanguageIsoCode()));
-				DrawStringMultiLine(r.left, r.right, r.top, UINT16_MAX, STR_BLACK_RAW_STRING);
+				DrawString(r.left, r.right, r.top, STR_BLACK_RAW_STRING);
 				break;
 
 			case WID_GO_BASE_MUSIC_DESCRIPTION:
 				SetDParamStr(0, BaseMusic::GetUsedSet()->GetDescription(GetCurrentLanguageIsoCode()));
-				DrawStringMultiLine(r.left, r.right, r.top, UINT16_MAX, STR_BLACK_RAW_STRING);
+				DrawString(r.left, r.right, r.top, STR_BLACK_RAW_STRING);
 				break;
 		}
 	}
@@ -344,7 +344,7 @@
 			case WID_GO_BASE_GRF_DESCRIPTION:
 				/* Find the biggest description for the default size. */
 				for (int i = 0; i < BaseGraphics::GetNumSets(); i++) {
-					SetDParamStr(0, BaseGraphics::GetSet(i)->GetDescription(GetCurrentLanguageIsoCode()));
+					SetDParamStr(0, "123");
 					size->height = max(size->height, (uint)GetStringHeight(STR_BLACK_RAW_STRING, size->width));
 				}
 				break;
@@ -363,7 +363,7 @@
 			case WID_GO_BASE_SFX_DESCRIPTION:
 				/* Find the biggest description for the default size. */
 				for (int i = 0; i < BaseSounds::GetNumSets(); i++) {
-					SetDParamStr(0, BaseSounds::GetSet(i)->GetDescription(GetCurrentLanguageIsoCode()));
+					SetDParamStr(0, "123");
 					size->height = max(size->height, (uint)GetStringHeight(STR_BLACK_RAW_STRING, size->width));
 				}
 				break;
@@ -371,7 +371,7 @@
 			case WID_GO_BASE_MUSIC_DESCRIPTION:
 				/* Find the biggest description for the default size. */
 				for (int i = 0; i < BaseMusic::GetNumSets(); i++) {
-					SetDParamStr(0, BaseMusic::GetSet(i)->GetDescription(GetCurrentLanguageIsoCode()));
+					SetDParamStr(0, "123");
 					size->height = max(size->height, (uint)GetStringHeight(STR_BLACK_RAW_STRING, size->width));
 				}
 				break;
--- src/sound/sdl_s.cpp	2014-02-25 11:16:59.000000000 +0200
+++ src/sound/sdl_s.cpp	2014-03-13 22:51:42.431059430 +0200
@@ -21,6 +21,10 @@
 /** Factory for the SDL sound driver. */
 static FSoundDriver_SDL iFSoundDriver_SDL;
 
+#ifdef __ANDROID__
+extern void Android_MidiMixMusic(Sint16 *stream, int len);
+#endif
+
 /**
  * Callback that fills the sound buffer.
  * @param userdata Ignored.
@@ -30,6 +34,9 @@
 static void CDECL fill_sound_buffer(void *userdata, Uint8 *stream, int len)
 {
 	MxMixSamples(stream, len / 4);
+#if defined(__ANDROID__) && defined(LIBTIMIDITY)
+	Android_MidiMixMusic((Sint16 *)stream, len / 2);
+#endif
 }
 
 const char *SoundDriver_SDL::Start(const char * const *parm)
--- src/strings.cpp	2014-02-25 11:17:24.000000000 +0200
+++ src/strings.cpp	2014-03-13 23:44:07.197919943 +0200
@@ -2005,7 +2005,7 @@
  * @return If glyphs are missing, return \c true, else return \c false.
  * @post If \c true is returned and str is not NULL, *str points to a string that is found to contain at least one missing glyph.
  */
-bool MissingGlyphSearcher::FindMissingGlyphs(const char **str)
+int MissingGlyphSearcher::FindMissingGlyphs(const char **str)
 {
 	InitFreeType(this->Monospace());
 	const Sprite *question_mark[FS_END];
@@ -2015,6 +2015,7 @@
 	}
 
 	this->Reset();
+	int missing = 0;
 	for (const char *text = this->NextString(); text != NULL; text = this->NextString()) {
 		FontSize size = this->DefaultSize();
 		if (str != NULL) *str = text;
@@ -2025,11 +2026,11 @@
 				size = FS_LARGE;
 			} else if (!IsInsideMM(c, SCC_SPRITE_START, SCC_SPRITE_END) && IsPrintable(c) && !IsTextDirectionChar(c) && c != '?' && GetGlyph(size, c) == question_mark[size]) {
 				/* The character is printable, but not in the normal font. This is the case we were testing for. */
-				return true;
+				missing++;
 			}
 		}
 	}
-	return false;
+	return missing;
 }
 
 /** Helper for searching through the language pack. */
--- src/strings_func.h	2014-02-25 11:17:24.000000000 +0200
+++ src/strings_func.h	2014-03-13 23:44:13.558298069 +0200
@@ -235,7 +235,7 @@
 	 */
 	virtual void SetFontNames(struct FreeTypeSettings *settings, const char *font_name) = 0;
 
-	bool FindMissingGlyphs(const char **str);
+	int FindMissingGlyphs(const char **str);
 };
 
 void CheckForMissingGlyphs(bool base_font = true, MissingGlyphSearcher *search = NULL);
--- src/video/sdl_v.cpp	2014-02-25 11:16:44.000000000 +0200
+++ src/video/sdl_v.cpp	2014-03-13 22:51:42.431059430 +0200
@@ -25,6 +25,9 @@
 #include "../fileio_func.h"
 #include "sdl_v.h"
 #include <SDL.h>
+#ifdef __ANDROID__
+#include <SDL_screenkeyboard.h>
+#endif
 
 static FVideoDriver_SDL iFVideoDriver_SDL;
 
@@ -349,6 +352,15 @@
 	 * surface, for example). */
 	_requested_hwpalette = want_hwpalette;
 
+#ifdef __ANDROID__
+	SDL_Rect r;
+	r.h = SDL_ListModes(NULL, 0)[0]->h / 10;
+	r.w = r.h;
+	r.x = SDL_ListModes(NULL, 0)[0]->w - r.w;
+	r.y = SDL_ListModes(NULL, 0)[0]->h - r.h;
+	SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT, &r);
+#endif
+
 	/* DO NOT CHANGE TO HWSURFACE, IT DOES NOT WORK */
 	newscreen = SDL_CALL SDL_SetVideoMode(w, h, bpp, SDL_SWSURFACE | (want_hwpalette ? SDL_HWPALETTE : 0) | (_fullscreen ? SDL_FULLSCREEN : SDL_RESIZABLE));
 	if (newscreen == NULL) {
@@ -521,6 +533,8 @@
 	if (sym->scancode == 49) key = WKC_BACKSPACE;
 #elif defined(__sgi__)
 	if (sym->scancode == 22) key = WKC_BACKQUOTE;
+#elif defined(__ANDROID__)
+	if (sym->scancode == SDLK_BACKQUOTE) key = WKC_BACKQUOTE;
 #else
 	if (sym->scancode == 49) key = WKC_BACKQUOTE;
 #endif
@@ -597,7 +611,7 @@
 			}
 			HandleMouseEvents();
 			break;
-
+#ifndef __ANDROID__
 		case SDL_ACTIVEEVENT:
 			if (!(ev.active.state & SDL_APPMOUSEFOCUS)) break;
 
@@ -608,7 +622,7 @@
 				_cursor.in_window = false;
 			}
 			break;
-
+#endif /* not __ANDROID__ */
 		case SDL_QUIT:
 			HandleExitGameRequest();
 			break;
@@ -623,13 +637,14 @@
 				HandleKeypress(keycode, character);
 			}
 			break;
-
+#ifndef __ANDROID__
 		case SDL_VIDEORESIZE: {
 			int w = max(ev.resize.w, 64);
 			int h = max(ev.resize.h, 64);
 			CreateMainSurface(w, h);
 			break;
 		}
+#endif /* not __ANDROID__ */
 		case SDL_VIDEOEXPOSE: {
 			/* Force a redraw of the entire screen. Note
 			 * that SDL 1.2 seems to do this automatically
@@ -661,6 +676,9 @@
 	SetupKeyboard();
 
 	_draw_threaded = GetDriverParam(parm, "no_threads") == NULL && GetDriverParam(parm, "no_thread") == NULL;
+#ifdef __ANDROID__
+	_draw_threaded = false;
+#endif
 
 	return NULL;
 }
